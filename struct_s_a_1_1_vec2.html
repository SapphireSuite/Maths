<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SA_Maths: SA::Vec2&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SA_Maths
   </div>
   <div id="projectbrief">Sapphire Suite&#39;s C++ Maths Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>SA</b></li><li class="navelem"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="struct_s_a_1_1_vec2-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SA::Vec2&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><em>Vector</em> 2 Sapphire's class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_vector2_8hpp_source.html">Vector2.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3df3e3ce1d8e3f31368ef27248569581" id="r_a3df3e3ce1d8e3f31368ef27248569581"><td class="memItemLeft" align="right" valign="top"><a id="a3df3e3ce1d8e3f31368ef27248569581" name="a3df3e3ce1d8e3f31368ef27248569581"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> = T</td></tr>
<tr class="memdesc:a3df3e3ce1d8e3f31368ef27248569581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type of the Vector. <br /></td></tr>
<tr class="separator:a3df3e3ce1d8e3f31368ef27248569581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f7383cc80a31f412e51a8d0c7970f66" id="r_a6f7383cc80a31f412e51a8d0c7970f66"><td class="memItemLeft" align="right" valign="top"><a id="a6f7383cc80a31f412e51a8d0c7970f66" name="a6f7383cc80a31f412e51a8d0c7970f66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2</b> ()=default</td></tr>
<tr class="memdesc:a6f7383cc80a31f412e51a8d0c7970f66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> constructor. <br /></td></tr>
<tr class="separator:a6f7383cc80a31f412e51a8d0c7970f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848927dc58f4d9faa546f49b8a9f0575" id="r_a848927dc58f4d9faa546f49b8a9f0575"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848927dc58f4d9faa546f49b8a9f0575">Vec2</a> (T _x, T _y) noexcept</td></tr>
<tr class="memdesc:a848927dc58f4d9faa546f49b8a9f0575"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor.  <br /></td></tr>
<tr class="separator:a848927dc58f4d9faa546f49b8a9f0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758d29c89d4ef598505965af61d22001" id="r_a758d29c89d4ef598505965af61d22001"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a758d29c89d4ef598505965af61d22001">Vec2</a> (T _scale) noexcept</td></tr>
<tr class="memdesc:a758d29c89d4ef598505965af61d22001"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> <em>Value</em> constructor.  <br /></td></tr>
<tr class="separator:a758d29c89d4ef598505965af61d22001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10639eac3804fe32e5960db4a834612a" id="r_a10639eac3804fe32e5960db4a834612a"><td class="memItemLeft" align="right" valign="top"><a id="a10639eac3804fe32e5960db4a834612a" name="a10639eac3804fe32e5960db4a834612a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2</b> (<a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a10639eac3804fe32e5960db4a834612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:a10639eac3804fe32e5960db4a834612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7279f8ea78087c78963bcb429d71e0f" id="r_ad7279f8ea78087c78963bcb429d71e0f"><td class="memItemLeft" align="right" valign="top"><a id="ad7279f8ea78087c78963bcb429d71e0f" name="ad7279f8ea78087c78963bcb429d71e0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2</b> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;)=default</td></tr>
<tr class="memdesc:ad7279f8ea78087c78963bcb429d71e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:ad7279f8ea78087c78963bcb429d71e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1803ba76f5fa420693e184a97a23f929" id="r_a1803ba76f5fa420693e184a97a23f929"><td class="memTemplParams" colspan="2">template&lt;typename TIn &gt; </td></tr>
<tr class="memitem:a1803ba76f5fa420693e184a97a23f929"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1803ba76f5fa420693e184a97a23f929">Vec2</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; TIn &gt; &amp;_other) noexcept</td></tr>
<tr class="memdesc:a1803ba76f5fa420693e184a97a23f929"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor from another <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a> type.  <br /></td></tr>
<tr class="separator:a1803ba76f5fa420693e184a97a23f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5091dde3d81081b411b26e1e3ade0a64" id="r_a5091dde3d81081b411b26e1e3ade0a64"><td class="memTemplParams" colspan="2">template&lt;typename TIn &gt; </td></tr>
<tr class="memitem:a5091dde3d81081b411b26e1e3ade0a64"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5091dde3d81081b411b26e1e3ade0a64">Vec2</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; TIn &gt; &amp;_other) noexcept</td></tr>
<tr class="memdesc:a5091dde3d81081b411b26e1e3ade0a64"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a>.  <br /></td></tr>
<tr class="separator:a5091dde3d81081b411b26e1e3ade0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61004eb58ab1486cba88770e59cd053d" id="r_a61004eb58ab1486cba88770e59cd053d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61004eb58ab1486cba88770e59cd053d">IsZero</a> () const noexcept</td></tr>
<tr class="memdesc:a61004eb58ab1486cba88770e59cd053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this vector is a zero vector.  <br /></td></tr>
<tr class="separator:a61004eb58ab1486cba88770e59cd053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb5b86e2f1e3c35e26d643fecbed608" id="r_a6bb5b86e2f1e3c35e26d643fecbed608"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb5b86e2f1e3c35e26d643fecbed608">Equals</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_other, T _epsilon=std::numeric_limits&lt; T &gt;::epsilon()) const noexcept</td></tr>
<tr class="memdesc:a6bb5b86e2f1e3c35e26d643fecbed608"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector.  <br /></td></tr>
<tr class="separator:a6bb5b86e2f1e3c35e26d643fecbed608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3594169e462dca34d90d3a2f272970" id="r_aea3594169e462dca34d90d3a2f272970"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3594169e462dca34d90d3a2f272970">operator==</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:aea3594169e462dca34d90d3a2f272970"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector equality.  <br /></td></tr>
<tr class="separator:aea3594169e462dca34d90d3a2f272970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b94f1e0423077478b32b49e52ce5cb" id="r_a06b94f1e0423077478b32b49e52ce5cb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b94f1e0423077478b32b49e52ce5cb">operator!=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a06b94f1e0423077478b32b49e52ce5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector inequality.  <br /></td></tr>
<tr class="separator:a06b94f1e0423077478b32b49e52ce5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60869d792469eb5cb82ff6608c55e63d" id="r_a60869d792469eb5cb82ff6608c55e63d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60869d792469eb5cb82ff6608c55e63d">Data</a> () noexcept</td></tr>
<tr class="memdesc:a60869d792469eb5cb82ff6608c55e63d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of vector data  <br /></td></tr>
<tr class="separator:a60869d792469eb5cb82ff6608c55e63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34443665d78e47c467d79f0b1c25059d" id="r_a34443665d78e47c467d79f0b1c25059d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34443665d78e47c467d79f0b1c25059d">Data</a> () const noexcept</td></tr>
<tr class="memdesc:a34443665d78e47c467d79f0b1c25059d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em> Const Getter </em> of vector data  <br /></td></tr>
<tr class="separator:a34443665d78e47c467d79f0b1c25059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fbe37e88ccbce2cd84fa34fafa1d7" id="r_afc0fbe37e88ccbce2cd84fa34fafa1d7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0fbe37e88ccbce2cd84fa34fafa1d7">operator[]</a> (uint32_t _index)</td></tr>
<tr class="memdesc:afc0fbe37e88ccbce2cd84fa34fafa1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Access</em> operator by index: x, y using 0, 1.  <br /></td></tr>
<tr class="separator:afc0fbe37e88ccbce2cd84fa34fafa1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab2a31f88373596ad447c1525ab207b" id="r_acab2a31f88373596ad447c1525ab207b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab2a31f88373596ad447c1525ab207b">operator[]</a> (uint32_t _index) const</td></tr>
<tr class="memdesc:acab2a31f88373596ad447c1525ab207b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em> Const Access </em> operator by index: x, y using 0, 1.  <br /></td></tr>
<tr class="separator:acab2a31f88373596ad447c1525ab207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacff8807916523f4fd92d5fcf1a3cc0" id="r_aeacff8807916523f4fd92d5fcf1a3cc0"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeacff8807916523f4fd92d5fcf1a3cc0">Length</a> () const</td></tr>
<tr class="memdesc:aeacff8807916523f4fd92d5fcf1a3cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the /b length of this vector.  <br /></td></tr>
<tr class="separator:aeacff8807916523f4fd92d5fcf1a3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4686a8e0f03de3e18cb157e2d97dff" id="r_a6d4686a8e0f03de3e18cb157e2d97dff"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d4686a8e0f03de3e18cb157e2d97dff">SqrLength</a> () const noexcept</td></tr>
<tr class="memdesc:a6d4686a8e0f03de3e18cb157e2d97dff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the <b> Squared Length </b> of this vector.  <br /></td></tr>
<tr class="separator:a6d4686a8e0f03de3e18cb157e2d97dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419f09a27e33112176e5cf249056e6c9" id="r_a419f09a27e33112176e5cf249056e6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419f09a27e33112176e5cf249056e6c9">Normalize</a> ()</td></tr>
<tr class="memdesc:a419f09a27e33112176e5cf249056e6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Normalize</b> this vector.  <br /></td></tr>
<tr class="separator:a419f09a27e33112176e5cf249056e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8aed838d3b1c330c02f6e6fb194d84" id="r_a8c8aed838d3b1c330c02f6e6fb194d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c8aed838d3b1c330c02f6e6fb194d84">GetNormalized</a> () const</td></tr>
<tr class="memdesc:a8c8aed838d3b1c330c02f6e6fb194d84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Normalize</b> this vector.  <br /></td></tr>
<tr class="separator:a8c8aed838d3b1c330c02f6e6fb194d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee806145504f8d890aeff12a5719ebb" id="r_aeee806145504f8d890aeff12a5719ebb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee806145504f8d890aeff12a5719ebb">IsNormalized</a> () const noexcept</td></tr>
<tr class="memdesc:aeee806145504f8d890aeff12a5719ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this vector is normalized.  <br /></td></tr>
<tr class="separator:aeee806145504f8d890aeff12a5719ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a835dfd490e1d1733ebc3946a7ce4d" id="r_a01a835dfd490e1d1733ebc3946a7ce4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a835dfd490e1d1733ebc3946a7ce4d">Reflect</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_normal, float _elasticity=1.0f) const noexcept</td></tr>
<tr class="memdesc:a01a835dfd490e1d1733ebc3946a7ce4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Reflect</b> this vector over the normal.  <br /></td></tr>
<tr class="separator:a01a835dfd490e1d1733ebc3946a7ce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef88fbe8f79dc7b32c736889ca63ff" id="r_a77ef88fbe8f79dc7b32c736889ca63ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ef88fbe8f79dc7b32c736889ca63ff">ProjectOnTo</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_other) const noexcept</td></tr>
<tr class="memdesc:a77ef88fbe8f79dc7b32c736889ca63ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Project</b> this vector onto an other vector.  <br /></td></tr>
<tr class="separator:a77ef88fbe8f79dc7b32c736889ca63ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325e253246446d312a4bce9381df31c6" id="r_a325e253246446d312a4bce9381df31c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a325e253246446d312a4bce9381df31c6">ProjectOnToNormal</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_normal) const noexcept</td></tr>
<tr class="memdesc:a325e253246446d312a4bce9381df31c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Project</b> this vector onto s normal.  <br /></td></tr>
<tr class="separator:a325e253246446d312a4bce9381df31c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6271d7a2af8663b8d842fd50373c79" id="r_a9d6271d7a2af8663b8d842fd50373c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d6271d7a2af8663b8d842fd50373c79">Perpendicular</a> () const noexcept</td></tr>
<tr class="memdesc:a9d6271d7a2af8663b8d842fd50373c79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the perpendicular vector to this vector.  <br /></td></tr>
<tr class="separator:a9d6271d7a2af8663b8d842fd50373c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb9f26934baedcc2e31571b5bbd66e" id="r_a91cb9f26934baedcc2e31571b5bbd66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cb9f26934baedcc2e31571b5bbd66e">operator=</a> (<a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a91cb9f26934baedcc2e31571b5bbd66e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> assignment move operator.  <br /></td></tr>
<tr class="separator:a91cb9f26934baedcc2e31571b5bbd66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b575e7c720620e767e2384b115d808a" id="r_a7b575e7c720620e767e2384b115d808a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b575e7c720620e767e2384b115d808a">operator=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;)=default</td></tr>
<tr class="memdesc:a7b575e7c720620e767e2384b115d808a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> assignment copy operator.  <br /></td></tr>
<tr class="separator:a7b575e7c720620e767e2384b115d808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bd3fe1077603fca50e478e10741bc6" id="r_a15bd3fe1077603fca50e478e10741bc6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15bd3fe1077603fca50e478e10741bc6">operator-</a> () const noexcept</td></tr>
<tr class="memdesc:a15bd3fe1077603fca50e478e10741bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the opposite signed vector.  <br /></td></tr>
<tr class="separator:a15bd3fe1077603fca50e478e10741bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf75b9429a5b44b895a294f6bb3fd77f" id="r_acf75b9429a5b44b895a294f6bb3fd77f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf75b9429a5b44b895a294f6bb3fd77f">operator*</a> (T _scale) const noexcept</td></tr>
<tr class="memdesc:acf75b9429a5b44b895a294f6bb3fd77f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:acf75b9429a5b44b895a294f6bb3fd77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f3d6baddef081f76ddc3bf00f6fc5" id="r_ac12f3d6baddef081f76ddc3bf00f6fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac12f3d6baddef081f76ddc3bf00f6fc5">operator/</a> (T _scale) const</td></tr>
<tr class="memdesc:ac12f3d6baddef081f76ddc3bf00f6fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Inverse Scale </b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:ac12f3d6baddef081f76ddc3bf00f6fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7fd0f2c2ed050062b3a4e4e1240547" id="r_a6c7fd0f2c2ed050062b3a4e4e1240547"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c7fd0f2c2ed050062b3a4e4e1240547">operator+</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a6c7fd0f2c2ed050062b3a4e4e1240547"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Add</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a6c7fd0f2c2ed050062b3a4e4e1240547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367879369c89c07f98135e7ab37f1268" id="r_a367879369c89c07f98135e7ab37f1268"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a367879369c89c07f98135e7ab37f1268">operator-</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a367879369c89c07f98135e7ab37f1268"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Subtract</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a367879369c89c07f98135e7ab37f1268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3bd839fd337d47ef247d1402ae83a" id="r_a62a3bd839fd337d47ef247d1402ae83a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a3bd839fd337d47ef247d1402ae83a">operator*</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a62a3bd839fd337d47ef247d1402ae83a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Multiply</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a62a3bd839fd337d47ef247d1402ae83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595a745ee7d106c65889edf42a2cbc20" id="r_a595a745ee7d106c65889edf42a2cbc20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a595a745ee7d106c65889edf42a2cbc20">operator/</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const</td></tr>
<tr class="memdesc:a595a745ee7d106c65889edf42a2cbc20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Divide</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a595a745ee7d106c65889edf42a2cbc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dbca2f4c4b7c7e2969f73d5bd5937a" id="r_ac1dbca2f4c4b7c7e2969f73d5bd5937a"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1dbca2f4c4b7c7e2969f73d5bd5937a">operator|</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:ac1dbca2f4c4b7c7e2969f73d5bd5937a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Dot product </b> between this and _rhs.  <br /></td></tr>
<tr class="separator:ac1dbca2f4c4b7c7e2969f73d5bd5937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453a1b9082011d41e9cf6ee37950c28" id="r_a0453a1b9082011d41e9cf6ee37950c28"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0453a1b9082011d41e9cf6ee37950c28">operator^</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a0453a1b9082011d41e9cf6ee37950c28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Cross product </b> between this and _rhs.  <br /></td></tr>
<tr class="separator:a0453a1b9082011d41e9cf6ee37950c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2cd996776dafdc1093e396b4cf3eb" id="r_aebb2cd996776dafdc1093e396b4cf3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebb2cd996776dafdc1093e396b4cf3eb">operator*=</a> (T _scale) noexcept</td></tr>
<tr class="memdesc:aebb2cd996776dafdc1093e396b4cf3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:aebb2cd996776dafdc1093e396b4cf3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823da58cc7884f1f4194bbc01fe7ffb" id="r_a9823da58cc7884f1f4194bbc01fe7ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9823da58cc7884f1f4194bbc01fe7ffb">operator/=</a> (T _scale)</td></tr>
<tr class="memdesc:a9823da58cc7884f1f4194bbc01fe7ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Inverse Scale </b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:a9823da58cc7884f1f4194bbc01fe7ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaea6381ae8b7cdc09f6f0faebe1865" id="r_aedaea6381ae8b7cdc09f6f0faebe1865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedaea6381ae8b7cdc09f6f0faebe1865">operator+=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:aedaea6381ae8b7cdc09f6f0faebe1865"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Add</b> term by term vector values.  <br /></td></tr>
<tr class="separator:aedaea6381ae8b7cdc09f6f0faebe1865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030d4a5b24373387637e90609c493d9c" id="r_a030d4a5b24373387637e90609c493d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a030d4a5b24373387637e90609c493d9c">operator-=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a030d4a5b24373387637e90609c493d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Substract</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a030d4a5b24373387637e90609c493d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e58bdc1c7fd884387bec40c628caa6" id="r_a62e58bdc1c7fd884387bec40c628caa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62e58bdc1c7fd884387bec40c628caa6">operator*=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a62e58bdc1c7fd884387bec40c628caa6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Multiply</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a62e58bdc1c7fd884387bec40c628caa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab333e54e8aa3ea01a91836920be04eb8" id="r_ab333e54e8aa3ea01a91836920be04eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab333e54e8aa3ea01a91836920be04eb8">operator/=</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs)</td></tr>
<tr class="memdesc:ab333e54e8aa3ea01a91836920be04eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Divide</b> term by term vector values.  <br /></td></tr>
<tr class="separator:ab333e54e8aa3ea01a91836920be04eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0a7e66df2260ceff324f91f4ebd486c" id="r_af0a7e66df2260ceff324f91f4ebd486c"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a7e66df2260ceff324f91f4ebd486c">Dot</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_lhs, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:af0a7e66df2260ceff324f91f4ebd486c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Dot product </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:af0a7e66df2260ceff324f91f4ebd486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621f43269455e012988aaef5f5adfc1" id="r_a5621f43269455e012988aaef5f5adfc1"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5621f43269455e012988aaef5f5adfc1">Cross</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_lhs, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a5621f43269455e012988aaef5f5adfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Cross product </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:a5621f43269455e012988aaef5f5adfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264d12f98913aed5d772a0c52bb0a4e" id="r_aa264d12f98913aed5d772a0c52bb0a4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa264d12f98913aed5d772a0c52bb0a4e">Angle</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:aa264d12f98913aed5d772a0c52bb0a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Signed Angle </b> between _start and _end.  <br /></td></tr>
<tr class="separator:aa264d12f98913aed5d772a0c52bb0a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff47f22dde453089477cb868c34ce82" id="r_a0ff47f22dde453089477cb868c34ce82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff47f22dde453089477cb868c34ce82">AngleUnsigned</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:a0ff47f22dde453089477cb868c34ce82"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Unsigned Angle </b> between _start and _end.  <br /></td></tr>
<tr class="separator:a0ff47f22dde453089477cb868c34ce82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b84fdb64eb537e28862008d658108" id="r_a022b84fdb64eb537e28862008d658108"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a022b84fdb64eb537e28862008d658108">Dist</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end)</td></tr>
<tr class="memdesc:a022b84fdb64eb537e28862008d658108"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Distance </b> between _start and _end.  <br /></td></tr>
<tr class="separator:a022b84fdb64eb537e28862008d658108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bfe37e68fb26e2072426f0fc977fe5" id="r_ad6bfe37e68fb26e2072426f0fc977fe5"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6bfe37e68fb26e2072426f0fc977fe5">SqrDist</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:ad6bfe37e68fb26e2072426f0fc977fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Squared Distance </b> between _start and _end.  <br /></td></tr>
<tr class="separator:ad6bfe37e68fb26e2072426f0fc977fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2a7cbd88befebd51151b91b1724c49" id="r_aaa2a7cbd88befebd51151b91b1724c49"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2a7cbd88befebd51151b91b1724c49">Dir</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:aaa2a7cbd88befebd51151b91b1724c49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Non-Normalized Direction </b> from _start to _end.  <br /></td></tr>
<tr class="separator:aaa2a7cbd88befebd51151b91b1724c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae224016c38329473dc307be9b267a021" id="r_ae224016c38329473dc307be9b267a021"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae224016c38329473dc307be9b267a021">DirN</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end)</td></tr>
<tr class="memdesc:ae224016c38329473dc307be9b267a021"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Normalized Direction </b> from _start to _end.  <br /></td></tr>
<tr class="separator:ae224016c38329473dc307be9b267a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6927bf7ae14d9c0838d033cc22aa27" id="r_a5b6927bf7ae14d9c0838d033cc22aa27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6927bf7ae14d9c0838d033cc22aa27">Lerp</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:a5b6927bf7ae14d9c0838d033cc22aa27"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Clamped Lerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:a5b6927bf7ae14d9c0838d033cc22aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc954477f2f1defc22cdf2ec53583c0e" id="r_acc954477f2f1defc22cdf2ec53583c0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc954477f2f1defc22cdf2ec53583c0e">LerpUnclamped</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:acc954477f2f1defc22cdf2ec53583c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Unclamped Lerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:acc954477f2f1defc22cdf2ec53583c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacce90be8b57c3a2050916d24e40389" id="r_acacce90be8b57c3a2050916d24e40389"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acacce90be8b57c3a2050916d24e40389">SLerp</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:acacce90be8b57c3a2050916d24e40389"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Clamped SLerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:acacce90be8b57c3a2050916d24e40389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f98376b6f83fc65dcb20fcc5615f8" id="r_aaf3f98376b6f83fc65dcb20fcc5615f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf3f98376b6f83fc65dcb20fcc5615f8">SLerpUnclamped</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:aaf3f98376b6f83fc65dcb20fcc5615f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Unclamped SLerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:aaf3f98376b6f83fc65dcb20fcc5615f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af4d12a46b350294e76698126c6cc1179" id="r_af4d12a46b350294e76698126c6cc1179"><td class="memItemLeft" align="right" valign="top"><a id="af4d12a46b350294e76698126c6cc1179" name="af4d12a46b350294e76698126c6cc1179"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>x</b> = T()</td></tr>
<tr class="memdesc:af4d12a46b350294e76698126c6cc1179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector's X component (axis value). <br /></td></tr>
<tr class="separator:af4d12a46b350294e76698126c6cc1179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af476eccb83c4798b3542a3a75fa34c8c" id="r_af476eccb83c4798b3542a3a75fa34c8c"><td class="memItemLeft" align="right" valign="top"><a id="af476eccb83c4798b3542a3a75fa34c8c" name="af476eccb83c4798b3542a3a75fa34c8c"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>y</b> = T()</td></tr>
<tr class="memdesc:af476eccb83c4798b3542a3a75fa34c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector's Y component (axis value). <br /></td></tr>
<tr class="separator:af476eccb83c4798b3542a3a75fa34c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac90b793a379e8b692606fd110a516820" id="r_ac90b793a379e8b692606fd110a516820"><td class="memItemLeft" align="right" valign="top"><a id="ac90b793a379e8b692606fd110a516820" name="ac90b793a379e8b692606fd110a516820"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Zero</b></td></tr>
<tr class="memdesc:ac90b793a379e8b692606fd110a516820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero vector constant { 0, 0 }. <br /></td></tr>
<tr class="separator:ac90b793a379e8b692606fd110a516820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba720cb1b41d07da02794d1109599125" id="r_aba720cb1b41d07da02794d1109599125"><td class="memItemLeft" align="right" valign="top"><a id="aba720cb1b41d07da02794d1109599125" name="aba720cb1b41d07da02794d1109599125"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>One</b></td></tr>
<tr class="memdesc:aba720cb1b41d07da02794d1109599125"><td class="mdescLeft">&#160;</td><td class="mdescRight">One vector constant { 1, 1 }. <br /></td></tr>
<tr class="separator:aba720cb1b41d07da02794d1109599125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7349caf84133cd9ea454f63f92622f" id="r_a5d7349caf84133cd9ea454f63f92622f"><td class="memItemLeft" align="right" valign="top"><a id="a5d7349caf84133cd9ea454f63f92622f" name="a5d7349caf84133cd9ea454f63f92622f"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Right</b></td></tr>
<tr class="memdesc:a5d7349caf84133cd9ea454f63f92622f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right vector constant { 1, 0 }. <br /></td></tr>
<tr class="separator:a5d7349caf84133cd9ea454f63f92622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc2fa9a464b67d93c69df6cbb142bbc" id="r_a2dc2fa9a464b67d93c69df6cbb142bbc"><td class="memItemLeft" align="right" valign="top"><a id="a2dc2fa9a464b67d93c69df6cbb142bbc" name="a2dc2fa9a464b67d93c69df6cbb142bbc"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Left</b></td></tr>
<tr class="memdesc:a2dc2fa9a464b67d93c69df6cbb142bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left vector constant { -1, 0 }. <br /></td></tr>
<tr class="separator:a2dc2fa9a464b67d93c69df6cbb142bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c6ffba383ca428099970af22a5b43" id="r_a362c6ffba383ca428099970af22a5b43"><td class="memItemLeft" align="right" valign="top"><a id="a362c6ffba383ca428099970af22a5b43" name="a362c6ffba383ca428099970af22a5b43"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Up</b></td></tr>
<tr class="memdesc:a362c6ffba383ca428099970af22a5b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up vector constant { 0, 1 }. <br /></td></tr>
<tr class="separator:a362c6ffba383ca428099970af22a5b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730bc497774d536c398aa8f5ecbd75a3" id="r_a730bc497774d536c398aa8f5ecbd75a3"><td class="memItemLeft" align="right" valign="top"><a id="a730bc497774d536c398aa8f5ecbd75a3" name="a730bc497774d536c398aa8f5ecbd75a3"></a>
static const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Down</b></td></tr>
<tr class="memdesc:a730bc497774d536c398aa8f5ecbd75a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down vector constant { 0, -1 }. <br /></td></tr>
<tr class="separator:a730bc497774d536c398aa8f5ecbd75a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
struct SA::Vec2&lt; T &gt;</div><p><em>Vector</em> 2 Sapphire's class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a848927dc58f4d9faa546f49b8a9f0575" name="a848927dc58f4d9faa546f49b8a9f0575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848927dc58f4d9faa546f49b8a9f0575">&#9670;&#160;</a></span>Vec2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Vec2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_x</td><td>X axis value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_y</td><td>Y axis value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a758d29c89d4ef598505965af61d22001" name="a758d29c89d4ef598505965af61d22001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758d29c89d4ef598505965af61d22001">&#9670;&#160;</a></span>Vec2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Vec2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> <em>Value</em> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Axis value to apply on all axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1803ba76f5fa420693e184a97a23f929" name="a1803ba76f5fa420693e184a97a23f929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1803ba76f5fa420693e184a97a23f929">&#9670;&#160;</a></span>Vec2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Vec2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; TIn &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor from another <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIn</td><td>Type of the input <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td><a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5091dde3d81081b411b26e1e3ade0a64" name="a5091dde3d81081b411b26e1e3ade0a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5091dde3d81081b411b26e1e3ade0a64">&#9670;&#160;</a></span>Vec2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Vec2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; TIn &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIn</td><td>Type of the input <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td><a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa264d12f98913aed5d772a0c52bb0a4e" name="aa264d12f98913aed5d772a0c52bb0a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa264d12f98913aed5d772a0c52bb0a4e">&#9670;&#160;</a></span>Angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Signed Angle </b> between _start and _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Starting point to compute angle from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Ending point to compute angle to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Signed Angle </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="a0ff47f22dde453089477cb868c34ce82" name="a0ff47f22dde453089477cb868c34ce82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff47f22dde453089477cb868c34ce82">&#9670;&#160;</a></span>AngleUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::AngleUnsigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Unsigned Angle </b> between _start and _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Starting point to compute angle from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Ending point to compute angle to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Unsigned Angle </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="a5621f43269455e012988aaef5f5adfc1" name="a5621f43269455e012988aaef5f5adfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5621f43269455e012988aaef5f5adfc1">&#9670;&#160;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Cross product </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_lhs</td><td>Left hand side operand to compute cross product with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand to compute cross product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Cross product </b> between _lhs and _rhs. </dd></dl>

</div>
</div>
<a id="a34443665d78e47c467d79f0b1c25059d" name="a34443665d78e47c467d79f0b1c25059d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34443665d78e47c467d79f0b1c25059d">&#9670;&#160;</a></span>Data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em> Const Getter </em> of vector data </p>
<dl class="section return"><dt>Returns</dt><dd>this vector as a const T*. </dd></dl>

</div>
</div>
<a id="a60869d792469eb5cb82ff6608c55e63d" name="a60869d792469eb5cb82ff6608c55e63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60869d792469eb5cb82ff6608c55e63d">&#9670;&#160;</a></span>Data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of vector data </p>
<dl class="section return"><dt>Returns</dt><dd>this vector as a T*. </dd></dl>

</div>
</div>
<a id="aaa2a7cbd88befebd51151b91b1724c49" name="aaa2a7cbd88befebd51151b91b1724c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2a7cbd88befebd51151b91b1724c49">&#9670;&#160;</a></span>Dir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Dir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Non-Normalized Direction </b> from _start to _end. </p>
<p>Direction get not normalized. Use DirN instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Starting point to compute direction from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>ending point to compute direction to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Non-Normalized Direction </b> from _start to _end. </dd></dl>

</div>
</div>
<a id="ae224016c38329473dc307be9b267a021" name="ae224016c38329473dc307be9b267a021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae224016c38329473dc307be9b267a021">&#9670;&#160;</a></span>DirN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::DirN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Normalized Direction </b> from _start to _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Starting point to compute direction from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>ending point to compute direction to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Normalized Direction </b> from _start to _end. </dd></dl>

</div>
</div>
<a id="a022b84fdb64eb537e28862008d658108" name="a022b84fdb64eb537e28862008d658108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022b84fdb64eb537e28862008d658108">&#9670;&#160;</a></span>Dist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Distance </b> between _start and _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute distance with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute distance with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Distance </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="af0a7e66df2260ceff324f91f4ebd486c" name="af0a7e66df2260ceff324f91f4ebd486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a7e66df2260ceff324f91f4ebd486c">&#9670;&#160;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Dot product </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_lhs</td><td>Left hand side operand to compute dot product with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand to compute dot product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Dot product </b> between _lhs and _rhs. </dd></dl>

</div>
</div>
<a id="a6bb5b86e2f1e3c35e26d643fecbed608" name="a6bb5b86e2f1e3c35e26d643fecbed608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb5b86e2f1e3c35e26d643fecbed608">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_epsilon</em><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;T&#160;&gt;::epsilon()</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Other vector to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_epsilon</td><td>Epsilon value for threshold comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _other are equal. </dd></dl>

</div>
</div>
<a id="a8c8aed838d3b1c330c02f6e6fb194d84" name="a8c8aed838d3b1c330c02f6e6fb194d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8aed838d3b1c330c02f6e6fb194d84">&#9670;&#160;</a></span>GetNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::GetNormalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Normalize</b> this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>new normalized vector. </dd></dl>

</div>
</div>
<a id="aeee806145504f8d890aeff12a5719ebb" name="aeee806145504f8d890aeff12a5719ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee806145504f8d890aeff12a5719ebb">&#9670;&#160;</a></span>IsNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::IsNormalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this vector is normalized. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this vector is normalized, otherwise false. </dd></dl>

</div>
</div>
<a id="a61004eb58ab1486cba88770e59cd053d" name="a61004eb58ab1486cba88770e59cd053d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61004eb58ab1486cba88770e59cd053d">&#9670;&#160;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::IsZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this vector is a zero vector. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this is a zero vector. </dd></dl>

</div>
</div>
<a id="aeacff8807916523f4fd92d5fcf1a3cc0" name="aeacff8807916523f4fd92d5fcf1a3cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacff8807916523f4fd92d5fcf1a3cc0">&#9670;&#160;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the /b length of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Length of this vector. </dd></dl>

</div>
</div>
<a id="a5b6927bf7ae14d9c0838d033cc22aa27" name="a5b6927bf7ae14d9c0838d033cc22aa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6927bf7ae14d9c0838d033cc22aa27">&#9670;&#160;</a></span>Lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Clamped Lerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Linear_interpolation">https://en.wikipedia.org/wiki/Linear_interpolation</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="acc954477f2f1defc22cdf2ec53583c0e" name="acc954477f2f1defc22cdf2ec53583c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc954477f2f1defc22cdf2ec53583c0e">&#9670;&#160;</a></span>LerpUnclamped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::LerpUnclamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Unclamped Lerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Linear_interpolation">https://en.wikipedia.org/wiki/Linear_interpolation</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="a419f09a27e33112176e5cf249056e6c9" name="a419f09a27e33112176e5cf249056e6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419f09a27e33112176e5cf249056e6c9">&#9670;&#160;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Normalize</b> this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector normalized. </dd></dl>

</div>
</div>
<a id="a06b94f1e0423077478b32b49e52ce5cb" name="a06b94f1e0423077478b32b49e52ce5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b94f1e0423077478b32b49e52ce5cb">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Other vector to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _rhs are non-equal. </dd></dl>

</div>
</div>
<a id="a62a3bd839fd337d47ef247d1402ae83a" name="a62a3bd839fd337d47ef247d1402ae83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3bd839fd337d47ef247d1402ae83a">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Multiply</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="acf75b9429a5b44b895a294f6bb3fd77f" name="acf75b9429a5b44b895a294f6bb3fd77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf75b9429a5b44b895a294f6bb3fd77f">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector scaled. </dd></dl>

</div>
</div>
<a id="a62e58bdc1c7fd884387bec40c628caa6" name="a62e58bdc1c7fd884387bec40c628caa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e58bdc1c7fd884387bec40c628caa6">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Multiply</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="aebb2cd996776dafdc1093e396b4cf3eb" name="aebb2cd996776dafdc1093e396b4cf3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb2cd996776dafdc1093e396b4cf3eb">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector scaled. </dd></dl>

</div>
</div>
<a id="a6c7fd0f2c2ed050062b3a4e4e1240547" name="a6c7fd0f2c2ed050062b3a4e4e1240547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7fd0f2c2ed050062b3a4e4e1240547">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Add</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="aedaea6381ae8b7cdc09f6f0faebe1865" name="aedaea6381ae8b7cdc09f6f0faebe1865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaea6381ae8b7cdc09f6f0faebe1865">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Add</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a15bd3fe1077603fca50e478e10741bc6" name="a15bd3fe1077603fca50e478e10741bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bd3fe1077603fca50e478e10741bc6">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the opposite signed vector. </p>
<dl class="section return"><dt>Returns</dt><dd>new opposite signed vector. </dd></dl>

</div>
</div>
<a id="a367879369c89c07f98135e7ab37f1268" name="a367879369c89c07f98135e7ab37f1268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367879369c89c07f98135e7ab37f1268">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Subtract</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to substract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="a030d4a5b24373387637e90609c493d9c" name="a030d4a5b24373387637e90609c493d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030d4a5b24373387637e90609c493d9c">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Substract</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to substract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a595a745ee7d106c65889edf42a2cbc20" name="a595a745ee7d106c65889edf42a2cbc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595a745ee7d106c65889edf42a2cbc20">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Divide</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to divide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="ac12f3d6baddef081f76ddc3bf00f6fc5" name="ac12f3d6baddef081f76ddc3bf00f6fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12f3d6baddef081f76ddc3bf00f6fc5">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Inverse Scale </b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Inverse scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector inverse-scaled. </dd></dl>

</div>
</div>
<a id="ab333e54e8aa3ea01a91836920be04eb8" name="ab333e54e8aa3ea01a91836920be04eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab333e54e8aa3ea01a91836920be04eb8">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Divide</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to divide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a9823da58cc7884f1f4194bbc01fe7ffb" name="a9823da58cc7884f1f4194bbc01fe7ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823da58cc7884f1f4194bbc01fe7ffb">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Inverse Scale </b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector inverse-scaled. </dd></dl>

</div>
</div>
<a id="a7b575e7c720620e767e2384b115d808a" name="a7b575e7c720620e767e2384b115d808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b575e7c720620e767e2384b115d808a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Default</em> assignment copy operator. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector assigned. </dd></dl>

</div>
</div>
<a id="a91cb9f26934baedcc2e31571b5bbd66e" name="a91cb9f26934baedcc2e31571b5bbd66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb9f26934baedcc2e31571b5bbd66e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Default</em> assignment move operator. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector assigned. </dd></dl>

</div>
</div>
<a id="aea3594169e462dca34d90d3a2f272970" name="aea3594169e462dca34d90d3a2f272970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3594169e462dca34d90d3a2f272970">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Other vector to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _rhs are equal. </dd></dl>

</div>
</div>
<a id="afc0fbe37e88ccbce2cd84fa34fafa1d7" name="afc0fbe37e88ccbce2cd84fa34fafa1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0fbe37e88ccbce2cd84fa34fafa1d7">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Access</em> operator by index: x, y using 0, 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T value at index. </dd></dl>

</div>
</div>
<a id="acab2a31f88373596ad447c1525ab207b" name="acab2a31f88373596ad447c1525ab207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab2a31f88373596ad447c1525ab207b">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em> Const Access </em> operator by index: x, y using 0, 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T value at index. </dd></dl>

</div>
</div>
<a id="a0453a1b9082011d41e9cf6ee37950c28" name="a0453a1b9082011d41e9cf6ee37950c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0453a1b9082011d41e9cf6ee37950c28">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Cross product </b> between this and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand vector to compute cross product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Cross product </b> between this vector and _other. </dd></dl>

</div>
</div>
<a id="ac1dbca2f4c4b7c7e2969f73d5bd5937a" name="ac1dbca2f4c4b7c7e2969f73d5bd5937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dbca2f4c4b7c7e2969f73d5bd5937a">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Dot product </b> between this and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand vector to compute dot product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Dot product </b> between this vector and _other. </dd></dl>

</div>
</div>
<a id="a9d6271d7a2af8663b8d842fd50373c79" name="a9d6271d7a2af8663b8d842fd50373c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6271d7a2af8663b8d842fd50373c79">&#9670;&#160;</a></span>Perpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Perpendicular </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the perpendicular vector to this vector. </p>
<p>Rotate this vector 90 degrees in trigonomety direction (counter-clockwise).</p>
<dl class="section return"><dt>Returns</dt><dd>new vector rotated. </dd></dl>

</div>
</div>
<a id="a77ef88fbe8f79dc7b32c736889ca63ff" name="a77ef88fbe8f79dc7b32c736889ca63ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef88fbe8f79dc7b32c736889ca63ff">&#9670;&#160;</a></span>ProjectOnTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::ProjectOnTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Project</b> this vector onto an other vector. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Vector_projection">https://en.wikipedia.org/wiki/Vector_projection</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Vector used for projection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector projected. </dd></dl>

</div>
</div>
<a id="a325e253246446d312a4bce9381df31c6" name="a325e253246446d312a4bce9381df31c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325e253246446d312a4bce9381df31c6">&#9670;&#160;</a></span>ProjectOnToNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::ProjectOnToNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_normal</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Project</b> this vector onto s normal. </p>
<p>Assume _normal is normalized. Use <a class="el" href="#a77ef88fbe8f79dc7b32c736889ca63ff" title="Project this vector onto an other vector.">ProjectOnTo()</a> for non normalized vector. Reference: <a href="https://en.wikipedia.org/wiki/Vector_projection">https://en.wikipedia.org/wiki/Vector_projection</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_normal</td><td>Normal used for projection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector projected. </dd></dl>

</div>
</div>
<a id="a01a835dfd490e1d1733ebc3946a7ce4d" name="a01a835dfd490e1d1733ebc3946a7ce4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a835dfd490e1d1733ebc3946a7ce4d">&#9670;&#160;</a></span>Reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::Reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_normal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_elasticity</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Reflect</b> this vector over the normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_normal</td><td>Normal used for reflection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_elasticity</td><td>Elasticity reflection coefficient (use 1.0f for full reflection).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector reflected. </dd></dl>

</div>
</div>
<a id="acacce90be8b57c3a2050916d24e40389" name="acacce90be8b57c3a2050916d24e40389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacce90be8b57c3a2050916d24e40389">&#9670;&#160;</a></span>SLerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::SLerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Clamped SLerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Slerp">https://en.wikipedia.org/wiki/Slerp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="aaf3f98376b6f83fc65dcb20fcc5615f8" name="aaf3f98376b6f83fc65dcb20fcc5615f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3f98376b6f83fc65dcb20fcc5615f8">&#9670;&#160;</a></span>SLerpUnclamped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a> <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::SLerpUnclamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Unclamped SLerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Slerp">https://en.wikipedia.org/wiki/Slerp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="ad6bfe37e68fb26e2072426f0fc977fe5" name="ad6bfe37e68fb26e2072426f0fc977fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bfe37e68fb26e2072426f0fc977fe5">&#9670;&#160;</a></span>SqrDist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::SqrDist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Squared Distance </b> between _start and _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute squared distance with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute squared distance with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Squared Distance </b> between _start and _rhs. </dd></dl>

</div>
</div>
<a id="a6d4686a8e0f03de3e18cb157e2d97dff" name="a6d4686a8e0f03de3e18cb157e2d97dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4686a8e0f03de3e18cb157e2d97dff">&#9670;&#160;</a></span>SqrLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec2.html">SA::Vec2</a>&lt; T &gt;::SqrLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the <b> Squared Length </b> of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Squared length of this vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Include/SA/Maths/Space/<a class="el" href="_vector2_8hpp_source.html">Vector2.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
