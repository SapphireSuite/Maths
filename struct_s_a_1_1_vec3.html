<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SA_Maths: SA::Vec3&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SA_Maths
   </div>
   <div id="projectbrief">Sapphire Suite&#39;s C++ Maths Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>SA</b></li><li class="navelem"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="struct_s_a_1_1_vec3-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SA::Vec3&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><em>Vector</em> 3 Sapphire-Maths class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_vector3_8hpp_source.html">Vector3.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6571e0ccb69ae50a6fa9b01763099eae" id="r_a6571e0ccb69ae50a6fa9b01763099eae"><td class="memItemLeft" align="right" valign="top"><a id="a6571e0ccb69ae50a6fa9b01763099eae" name="a6571e0ccb69ae50a6fa9b01763099eae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b> = T</td></tr>
<tr class="memdesc:a6571e0ccb69ae50a6fa9b01763099eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Vector. <br /></td></tr>
<tr class="separator:a6571e0ccb69ae50a6fa9b01763099eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a351cdd14f6fc8d5342b2be2a110a09" id="r_a3a351cdd14f6fc8d5342b2be2a110a09"><td class="memItemLeft" align="right" valign="top"><a id="a3a351cdd14f6fc8d5342b2be2a110a09" name="a3a351cdd14f6fc8d5342b2be2a110a09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec3</b> ()=default</td></tr>
<tr class="memdesc:a3a351cdd14f6fc8d5342b2be2a110a09"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> constructor. <br /></td></tr>
<tr class="separator:a3a351cdd14f6fc8d5342b2be2a110a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec431798fa6c107ccb7300b76815a60c" id="r_aec431798fa6c107ccb7300b76815a60c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec431798fa6c107ccb7300b76815a60c">Vec3</a> (T _x, T _y, T _z) noexcept</td></tr>
<tr class="memdesc:aec431798fa6c107ccb7300b76815a60c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor.  <br /></td></tr>
<tr class="separator:aec431798fa6c107ccb7300b76815a60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a5f13141b691e44f654b2da01277c1" id="r_a34a5f13141b691e44f654b2da01277c1"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a5f13141b691e44f654b2da01277c1">Vec3</a> (T _scale) noexcept</td></tr>
<tr class="memdesc:a34a5f13141b691e44f654b2da01277c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> <em>Value</em> constructor.  <br /></td></tr>
<tr class="separator:a34a5f13141b691e44f654b2da01277c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfeceeaa0766d521b9d16da40f9d4f3" id="r_a8cfeceeaa0766d521b9d16da40f9d4f3"><td class="memItemLeft" align="right" valign="top"><a id="a8cfeceeaa0766d521b9d16da40f9d4f3" name="a8cfeceeaa0766d521b9d16da40f9d4f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec3</b> (<a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a8cfeceeaa0766d521b9d16da40f9d4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:a8cfeceeaa0766d521b9d16da40f9d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26aae3b03da3847d71866b08d8b67ce" id="r_ab26aae3b03da3847d71866b08d8b67ce"><td class="memItemLeft" align="right" valign="top"><a id="ab26aae3b03da3847d71866b08d8b67ce" name="ab26aae3b03da3847d71866b08d8b67ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vec3</b> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;)=default</td></tr>
<tr class="memdesc:ab26aae3b03da3847d71866b08d8b67ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:ab26aae3b03da3847d71866b08d8b67ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89169fa09731ddf5769ad309badc456a" id="r_a89169fa09731ddf5769ad309badc456a"><td class="memTemplParams" colspan="2">template&lt;typename TIn &gt; </td></tr>
<tr class="memitem:a89169fa09731ddf5769ad309badc456a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89169fa09731ddf5769ad309badc456a">Vec3</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; TIn &gt; &amp;_other) noexcept</td></tr>
<tr class="memdesc:a89169fa09731ddf5769ad309badc456a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor from another <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a> type.  <br /></td></tr>
<tr class="separator:a89169fa09731ddf5769ad309badc456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bd44fe25e3b919544c18bb5629cb16" id="r_a95bd44fe25e3b919544c18bb5629cb16"><td class="memTemplParams" colspan="2">template&lt;typename TIn &gt; </td></tr>
<tr class="memitem:a95bd44fe25e3b919544c18bb5629cb16"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95bd44fe25e3b919544c18bb5629cb16">Vec3</a> (const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; TIn &gt; &amp;_other, T _z=T(0)) noexcept</td></tr>
<tr class="memdesc:a95bd44fe25e3b919544c18bb5629cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a>.  <br /></td></tr>
<tr class="separator:a95bd44fe25e3b919544c18bb5629cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d231da05962b084e351b8e432be1d31" id="r_a9d231da05962b084e351b8e432be1d31"><td class="memTemplParams" colspan="2">template&lt;typename TIn &gt; </td></tr>
<tr class="memitem:a9d231da05962b084e351b8e432be1d31"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d231da05962b084e351b8e432be1d31">Vec3</a> (const <a class="el" href="struct_s_a_1_1_vec4.html">Vec4</a>&lt; TIn &gt; &amp;_other) noexcept</td></tr>
<tr class="memdesc:a9d231da05962b084e351b8e432be1d31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec4.html" title="Vector 4 Sapphire-Maths class.">Vec4</a>.  <br /></td></tr>
<tr class="separator:a9d231da05962b084e351b8e432be1d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726eab4432b10af061a37a03bfcd5e47" id="r_a726eab4432b10af061a37a03bfcd5e47"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726eab4432b10af061a37a03bfcd5e47">IsZero</a> () const noexcept</td></tr>
<tr class="memdesc:a726eab4432b10af061a37a03bfcd5e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this vector is a zero vector.  <br /></td></tr>
<tr class="separator:a726eab4432b10af061a37a03bfcd5e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761ac855d03dab745b94c4dce7cb7d2e" id="r_a761ac855d03dab745b94c4dce7cb7d2e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a761ac855d03dab745b94c4dce7cb7d2e">Equals</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_other, T _epsilon=std::numeric_limits&lt; T &gt;::epsilon()) const noexcept</td></tr>
<tr class="memdesc:a761ac855d03dab745b94c4dce7cb7d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector.  <br /></td></tr>
<tr class="separator:a761ac855d03dab745b94c4dce7cb7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746e117053cd6c1232cfea46b476185f" id="r_a746e117053cd6c1232cfea46b476185f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a746e117053cd6c1232cfea46b476185f">operator==</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a746e117053cd6c1232cfea46b476185f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector equality.  <br /></td></tr>
<tr class="separator:a746e117053cd6c1232cfea46b476185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccd574163e1760185bc35abb457c9c9" id="r_a8ccd574163e1760185bc35abb457c9c9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ccd574163e1760185bc35abb457c9c9">operator!=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a8ccd574163e1760185bc35abb457c9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compare</em> 2 vector inequality.  <br /></td></tr>
<tr class="separator:a8ccd574163e1760185bc35abb457c9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f1214681c2e9b5cc052bf0e3c9d310" id="r_ab3f1214681c2e9b5cc052bf0e3c9d310"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f1214681c2e9b5cc052bf0e3c9d310">Data</a> () noexcept</td></tr>
<tr class="memdesc:ab3f1214681c2e9b5cc052bf0e3c9d310"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of vector data  <br /></td></tr>
<tr class="separator:ab3f1214681c2e9b5cc052bf0e3c9d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba337b1bd3b27961ccddab13aad517b1" id="r_aba337b1bd3b27961ccddab13aad517b1"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba337b1bd3b27961ccddab13aad517b1">Data</a> () const noexcept</td></tr>
<tr class="memdesc:aba337b1bd3b27961ccddab13aad517b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em> Const Getter </em> of vector data  <br /></td></tr>
<tr class="separator:aba337b1bd3b27961ccddab13aad517b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2eab184cc6f2072181363d97c7577" id="r_a0ef2eab184cc6f2072181363d97c7577"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ef2eab184cc6f2072181363d97c7577">operator[]</a> (uint32_t _index)</td></tr>
<tr class="memdesc:a0ef2eab184cc6f2072181363d97c7577"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Access</em> operator by index: x, y, z using 0, 1, 2.  <br /></td></tr>
<tr class="separator:a0ef2eab184cc6f2072181363d97c7577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b5f54f2425e67cbe7b215e52b190b8" id="r_a46b5f54f2425e67cbe7b215e52b190b8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b5f54f2425e67cbe7b215e52b190b8">operator[]</a> (uint32_t _index) const</td></tr>
<tr class="memdesc:a46b5f54f2425e67cbe7b215e52b190b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em> Const Access </em> operator by index: x, y, z using 0, 1, 2.  <br /></td></tr>
<tr class="separator:a46b5f54f2425e67cbe7b215e52b190b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c7de3637a67dc4fa044556aa23ad66" id="r_a41c7de3637a67dc4fa044556aa23ad66"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41c7de3637a67dc4fa044556aa23ad66">Length</a> () const</td></tr>
<tr class="memdesc:a41c7de3637a67dc4fa044556aa23ad66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the <b>length</b> of this vector.  <br /></td></tr>
<tr class="separator:a41c7de3637a67dc4fa044556aa23ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f08fa9b7568e25e1c5092dfc5d20e" id="r_a633f08fa9b7568e25e1c5092dfc5d20e"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a633f08fa9b7568e25e1c5092dfc5d20e">SqrLength</a> () const noexcept</td></tr>
<tr class="memdesc:a633f08fa9b7568e25e1c5092dfc5d20e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the <b> Squared Length </b> of this vector.  <br /></td></tr>
<tr class="separator:a633f08fa9b7568e25e1c5092dfc5d20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905cfba1c7382fb66570f0f8153aeea" id="r_a5905cfba1c7382fb66570f0f8153aeea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5905cfba1c7382fb66570f0f8153aeea">Normalize</a> ()</td></tr>
<tr class="memdesc:a5905cfba1c7382fb66570f0f8153aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Normalize</b> this vector.  <br /></td></tr>
<tr class="separator:a5905cfba1c7382fb66570f0f8153aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8de02dadba2d97a0547186cb2bb29f" id="r_a5e8de02dadba2d97a0547186cb2bb29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8de02dadba2d97a0547186cb2bb29f">GetNormalized</a> () const</td></tr>
<tr class="memdesc:a5e8de02dadba2d97a0547186cb2bb29f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Normalize</b> this vector.  <br /></td></tr>
<tr class="separator:a5e8de02dadba2d97a0547186cb2bb29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f94fba204d00430eb46e4a76f7dd6c9" id="r_a9f94fba204d00430eb46e4a76f7dd6c9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f94fba204d00430eb46e4a76f7dd6c9">IsNormalized</a> () const noexcept</td></tr>
<tr class="memdesc:a9f94fba204d00430eb46e4a76f7dd6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this vector is normalized.  <br /></td></tr>
<tr class="separator:a9f94fba204d00430eb46e4a76f7dd6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a031a8a58021b0ce27217a3c40bc1" id="r_a189a031a8a58021b0ce27217a3c40bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a189a031a8a58021b0ce27217a3c40bc1">Reflect</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_normal, float _elasticity=1.0f) const noexcept</td></tr>
<tr class="memdesc:a189a031a8a58021b0ce27217a3c40bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Reflect</b> this vector over the normal.  <br /></td></tr>
<tr class="separator:a189a031a8a58021b0ce27217a3c40bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea75b9cb08de179b249e2c64f5b6fc9b" id="r_aea75b9cb08de179b249e2c64f5b6fc9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea75b9cb08de179b249e2c64f5b6fc9b">ProjectOnTo</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_other) const noexcept</td></tr>
<tr class="memdesc:aea75b9cb08de179b249e2c64f5b6fc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Project</b> this vector onto an other vector.  <br /></td></tr>
<tr class="separator:aea75b9cb08de179b249e2c64f5b6fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6364017ec7e21931758bccbd41fa02bf" id="r_a6364017ec7e21931758bccbd41fa02bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6364017ec7e21931758bccbd41fa02bf">ProjectOnToNormal</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_normal) const noexcept</td></tr>
<tr class="memdesc:a6364017ec7e21931758bccbd41fa02bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Project</b> this vector onto s normal.  <br /></td></tr>
<tr class="separator:a6364017ec7e21931758bccbd41fa02bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5fb3e002e81a64f4a1e124ee467385" id="r_aaa5fb3e002e81a64f4a1e124ee467385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa5fb3e002e81a64f4a1e124ee467385">operator=</a> (<a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:aaa5fb3e002e81a64f4a1e124ee467385"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> assignment move operator.  <br /></td></tr>
<tr class="separator:aaa5fb3e002e81a64f4a1e124ee467385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e58bc3a008795ef4c716299023011f9" id="r_a9e58bc3a008795ef4c716299023011f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e58bc3a008795ef4c716299023011f9">operator=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;)=default</td></tr>
<tr class="memdesc:a9e58bc3a008795ef4c716299023011f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Default</em> assignment copy operator.  <br /></td></tr>
<tr class="separator:a9e58bc3a008795ef4c716299023011f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db551395c1001204006254fa125fd69" id="r_a9db551395c1001204006254fa125fd69"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9db551395c1001204006254fa125fd69">operator-</a> () const noexcept</td></tr>
<tr class="memdesc:a9db551395c1001204006254fa125fd69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Getter</em> of the opposite signed vector.  <br /></td></tr>
<tr class="separator:a9db551395c1001204006254fa125fd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554b40b3322fda63d5a6b0919ad0a732" id="r_a554b40b3322fda63d5a6b0919ad0a732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a554b40b3322fda63d5a6b0919ad0a732">operator*</a> (T _scale) const noexcept</td></tr>
<tr class="memdesc:a554b40b3322fda63d5a6b0919ad0a732"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:a554b40b3322fda63d5a6b0919ad0a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf4f9aef52c0d120ab1f07ebbaa251" id="r_a99bf4f9aef52c0d120ab1f07ebbaa251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99bf4f9aef52c0d120ab1f07ebbaa251">operator/</a> (T _scale) const</td></tr>
<tr class="memdesc:a99bf4f9aef52c0d120ab1f07ebbaa251"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Inverse Scale </b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:a99bf4f9aef52c0d120ab1f07ebbaa251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad502d20a06154370025dcaeba650fd" id="r_a8ad502d20a06154370025dcaeba650fd"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad502d20a06154370025dcaeba650fd">operator+</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a8ad502d20a06154370025dcaeba650fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Add</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a8ad502d20a06154370025dcaeba650fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbf31a6928f34e982587ed59b1597c8" id="r_aafbf31a6928f34e982587ed59b1597c8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafbf31a6928f34e982587ed59b1597c8">operator-</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:aafbf31a6928f34e982587ed59b1597c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Subtract</b> term by term vector values.  <br /></td></tr>
<tr class="separator:aafbf31a6928f34e982587ed59b1597c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da21e9d0e4f0194cc2ec2aabcfacbaf" id="r_a6da21e9d0e4f0194cc2ec2aabcfacbaf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da21e9d0e4f0194cc2ec2aabcfacbaf">operator*</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a6da21e9d0e4f0194cc2ec2aabcfacbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Multiply</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a6da21e9d0e4f0194cc2ec2aabcfacbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d02d7319cae213ce2dd4f295fe5251" id="r_ac7d02d7319cae213ce2dd4f295fe5251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7d02d7319cae213ce2dd4f295fe5251">operator/</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const</td></tr>
<tr class="memdesc:ac7d02d7319cae213ce2dd4f295fe5251"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Divide</b> term by term vector values.  <br /></td></tr>
<tr class="separator:ac7d02d7319cae213ce2dd4f295fe5251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a23365412643e0e5f1c95156d5b1c78" id="r_a8a23365412643e0e5f1c95156d5b1c78"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a23365412643e0e5f1c95156d5b1c78">operator|</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a8a23365412643e0e5f1c95156d5b1c78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Dot product </b> between this and _rhs.  <br /></td></tr>
<tr class="separator:a8a23365412643e0e5f1c95156d5b1c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2abde2aed199ac036f225dca64a908" id="r_a5f2abde2aed199ac036f225dca64a908"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f2abde2aed199ac036f225dca64a908">operator^</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) const noexcept</td></tr>
<tr class="memdesc:a5f2abde2aed199ac036f225dca64a908"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Cross product </b> between this and _rhs.  <br /></td></tr>
<tr class="separator:a5f2abde2aed199ac036f225dca64a908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcbbcbeacf84206b6937d2e11d898a4" id="r_a7bcbbcbeacf84206b6937d2e11d898a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bcbbcbeacf84206b6937d2e11d898a4">operator*=</a> (T _scale) noexcept</td></tr>
<tr class="memdesc:a7bcbbcbeacf84206b6937d2e11d898a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Scale</b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:a7bcbbcbeacf84206b6937d2e11d898a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f2258c5f01aa6d3d1b12bf36bc6fcc" id="r_a05f2258c5f01aa6d3d1b12bf36bc6fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05f2258c5f01aa6d3d1b12bf36bc6fcc">operator/=</a> (T _scale)</td></tr>
<tr class="memdesc:a05f2258c5f01aa6d3d1b12bf36bc6fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Inverse Scale </b> each vector axis by _scale.  <br /></td></tr>
<tr class="separator:a05f2258c5f01aa6d3d1b12bf36bc6fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71284584bbe88be07bfd0776bf6cd6d0" id="r_a71284584bbe88be07bfd0776bf6cd6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71284584bbe88be07bfd0776bf6cd6d0">operator+=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a71284584bbe88be07bfd0776bf6cd6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Add</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a71284584bbe88be07bfd0776bf6cd6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18577b167e7145aa2b63bb65eac44150" id="r_a18577b167e7145aa2b63bb65eac44150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18577b167e7145aa2b63bb65eac44150">operator-=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a18577b167e7145aa2b63bb65eac44150"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Substract</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a18577b167e7145aa2b63bb65eac44150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5739589a9a141b2bc668b1b995b80067" id="r_a5739589a9a141b2bc668b1b995b80067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5739589a9a141b2bc668b1b995b80067">operator*=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:a5739589a9a141b2bc668b1b995b80067"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Multiply</b> term by term vector values.  <br /></td></tr>
<tr class="separator:a5739589a9a141b2bc668b1b995b80067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb7fb34033777d10a52160a245c6de0" id="r_aaeb7fb34033777d10a52160a245c6de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeb7fb34033777d10a52160a245c6de0">operator/=</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs)</td></tr>
<tr class="memdesc:aaeb7fb34033777d10a52160a245c6de0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>Divide</b> term by term vector values.  <br /></td></tr>
<tr class="separator:aaeb7fb34033777d10a52160a245c6de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac65f5d482c808392ecba2aa95821c5fb" id="r_ac65f5d482c808392ecba2aa95821c5fb"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac65f5d482c808392ecba2aa95821c5fb">Dot</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_lhs, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:ac65f5d482c808392ecba2aa95821c5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Dot product </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:ac65f5d482c808392ecba2aa95821c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a16055dc020384c0600913db252d38" id="r_aa5a16055dc020384c0600913db252d38"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5a16055dc020384c0600913db252d38">Cross</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_lhs, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_rhs) noexcept</td></tr>
<tr class="memdesc:aa5a16055dc020384c0600913db252d38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Cross product </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:aa5a16055dc020384c0600913db252d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacccb9c1800f16d21f836c7bb53305" id="r_aefacccb9c1800f16d21f836c7bb53305"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefacccb9c1800f16d21f836c7bb53305">Angle</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_normal=<a class="el" href="#ae2d208e3d26dcd54ac44634cb13ff437">Vec3::Up</a>) noexcept</td></tr>
<tr class="memdesc:aefacccb9c1800f16d21f836c7bb53305"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Signed Angle </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:aefacccb9c1800f16d21f836c7bb53305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bea59741b832f9458c66b71ac38313" id="r_ad5bea59741b832f9458c66b71ac38313"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5bea59741b832f9458c66b71ac38313">AngleUnsigned</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:ad5bea59741b832f9458c66b71ac38313"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Unsigned Angle </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:ad5bea59741b832f9458c66b71ac38313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96584adc6b427565f338e1679664b20f" id="r_a96584adc6b427565f338e1679664b20f"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96584adc6b427565f338e1679664b20f">Dist</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end)</td></tr>
<tr class="memdesc:a96584adc6b427565f338e1679664b20f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Distance </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:a96584adc6b427565f338e1679664b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88592152a24687005ba4e63e88b6e96b" id="r_a88592152a24687005ba4e63e88b6e96b"><td class="memItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88592152a24687005ba4e63e88b6e96b">SqrDist</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:a88592152a24687005ba4e63e88b6e96b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Squared Distance </b> between _lhs and _rhs.  <br /></td></tr>
<tr class="separator:a88592152a24687005ba4e63e88b6e96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f9bcb7d23975847368556b8b349b6" id="r_ae08f9bcb7d23975847368556b8b349b6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae08f9bcb7d23975847368556b8b349b6">Dir</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end) noexcept</td></tr>
<tr class="memdesc:ae08f9bcb7d23975847368556b8b349b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Non-Normalized Direction </b> from _lhs and _rhs.  <br /></td></tr>
<tr class="separator:ae08f9bcb7d23975847368556b8b349b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6bbac4223c6780a24fcb00e7fb773c" id="r_a2d6bbac4223c6780a24fcb00e7fb773c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d6bbac4223c6780a24fcb00e7fb773c">DirN</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end)</td></tr>
<tr class="memdesc:a2d6bbac4223c6780a24fcb00e7fb773c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Compute</em> the <b> Normalized Direction </b> from _start to _end.  <br /></td></tr>
<tr class="separator:a2d6bbac4223c6780a24fcb00e7fb773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585fbd5402f1a99f3b770df9ca4268c" id="r_af585fbd5402f1a99f3b770df9ca4268c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af585fbd5402f1a99f3b770df9ca4268c">Lerp</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:af585fbd5402f1a99f3b770df9ca4268c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Clamped Lerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:af585fbd5402f1a99f3b770df9ca4268c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab418fd4903dae822dac2fecf590a50" id="r_a2ab418fd4903dae822dac2fecf590a50"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ab418fd4903dae822dac2fecf590a50">LerpUnclamped</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:a2ab418fd4903dae822dac2fecf590a50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Unclamped Lerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:a2ab418fd4903dae822dac2fecf590a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443b0b399993f9b8ac1edfde27c1e242" id="r_a443b0b399993f9b8ac1edfde27c1e242"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a443b0b399993f9b8ac1edfde27c1e242">SLerp</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:a443b0b399993f9b8ac1edfde27c1e242"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Clamped SLerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:a443b0b399993f9b8ac1edfde27c1e242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72833e3f8751a24e6fb85559178aad4b" id="r_a72833e3f8751a24e6fb85559178aad4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72833e3f8751a24e6fb85559178aad4b">SLerpUnclamped</a> (const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_start, const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp;_end, float _alpha) noexcept</td></tr>
<tr class="memdesc:a72833e3f8751a24e6fb85559178aad4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Unclamped SLerp </b> from _start to _end at _alpha.  <br /></td></tr>
<tr class="separator:a72833e3f8751a24e6fb85559178aad4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae7dc84bc5cea0a3e107092c540051130" id="r_ae7dc84bc5cea0a3e107092c540051130"><td class="memItemLeft" align="right" valign="top"><a id="ae7dc84bc5cea0a3e107092c540051130" name="ae7dc84bc5cea0a3e107092c540051130"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>x</b> = T()</td></tr>
<tr class="memdesc:ae7dc84bc5cea0a3e107092c540051130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector's X component (axis value). <br /></td></tr>
<tr class="separator:ae7dc84bc5cea0a3e107092c540051130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07354e9f33d631789871c36120d4b7a" id="r_ad07354e9f33d631789871c36120d4b7a"><td class="memItemLeft" align="right" valign="top"><a id="ad07354e9f33d631789871c36120d4b7a" name="ad07354e9f33d631789871c36120d4b7a"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>y</b> = T()</td></tr>
<tr class="memdesc:ad07354e9f33d631789871c36120d4b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector's Y component (axis value). <br /></td></tr>
<tr class="separator:ad07354e9f33d631789871c36120d4b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc0b46a270ef3bfc52bf094ab761f1" id="r_a3bfc0b46a270ef3bfc52bf094ab761f1"><td class="memItemLeft" align="right" valign="top"><a id="a3bfc0b46a270ef3bfc52bf094ab761f1" name="a3bfc0b46a270ef3bfc52bf094ab761f1"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>z</b> = T()</td></tr>
<tr class="memdesc:a3bfc0b46a270ef3bfc52bf094ab761f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector's Z component (axis value). <br /></td></tr>
<tr class="separator:a3bfc0b46a270ef3bfc52bf094ab761f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1ba4a592c03407200a25e00c679329e3" id="r_a1ba4a592c03407200a25e00c679329e3"><td class="memItemLeft" align="right" valign="top"><a id="a1ba4a592c03407200a25e00c679329e3" name="a1ba4a592c03407200a25e00c679329e3"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Zero</b></td></tr>
<tr class="memdesc:a1ba4a592c03407200a25e00c679329e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero vector constant {0, 0, 0}. <br /></td></tr>
<tr class="separator:a1ba4a592c03407200a25e00c679329e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10747cb6f890860678164d066fccbba" id="r_aa10747cb6f890860678164d066fccbba"><td class="memItemLeft" align="right" valign="top"><a id="aa10747cb6f890860678164d066fccbba" name="aa10747cb6f890860678164d066fccbba"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>One</b></td></tr>
<tr class="memdesc:aa10747cb6f890860678164d066fccbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">One vector constant {1, 1, 1}. <br /></td></tr>
<tr class="separator:aa10747cb6f890860678164d066fccbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c05f8d21b5e81ae1083c2000a8e0a2" id="r_a43c05f8d21b5e81ae1083c2000a8e0a2"><td class="memItemLeft" align="right" valign="top"><a id="a43c05f8d21b5e81ae1083c2000a8e0a2" name="a43c05f8d21b5e81ae1083c2000a8e0a2"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Right</b></td></tr>
<tr class="memdesc:a43c05f8d21b5e81ae1083c2000a8e0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right vector constant {1, 0, 0}. <br /></td></tr>
<tr class="separator:a43c05f8d21b5e81ae1083c2000a8e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5b64de7dd246ee8ba61975538b8851" id="r_aef5b64de7dd246ee8ba61975538b8851"><td class="memItemLeft" align="right" valign="top"><a id="aef5b64de7dd246ee8ba61975538b8851" name="aef5b64de7dd246ee8ba61975538b8851"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Left</b></td></tr>
<tr class="memdesc:aef5b64de7dd246ee8ba61975538b8851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left vector constant {-1, 0, 0}. <br /></td></tr>
<tr class="separator:aef5b64de7dd246ee8ba61975538b8851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d208e3d26dcd54ac44634cb13ff437" id="r_ae2d208e3d26dcd54ac44634cb13ff437"><td class="memItemLeft" align="right" valign="top"><a id="ae2d208e3d26dcd54ac44634cb13ff437" name="ae2d208e3d26dcd54ac44634cb13ff437"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Up</b></td></tr>
<tr class="memdesc:ae2d208e3d26dcd54ac44634cb13ff437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Up vector constant {0, 1, 0}. <br /></td></tr>
<tr class="separator:ae2d208e3d26dcd54ac44634cb13ff437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a93ca7d7a8184f20f48751937354186" id="r_a1a93ca7d7a8184f20f48751937354186"><td class="memItemLeft" align="right" valign="top"><a id="a1a93ca7d7a8184f20f48751937354186" name="a1a93ca7d7a8184f20f48751937354186"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Down</b></td></tr>
<tr class="memdesc:a1a93ca7d7a8184f20f48751937354186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down vector constant {0, -1, 0}. <br /></td></tr>
<tr class="separator:a1a93ca7d7a8184f20f48751937354186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8f1bd55a6c78007bd675fce5657613" id="r_a0b8f1bd55a6c78007bd675fce5657613"><td class="memItemLeft" align="right" valign="top"><a id="a0b8f1bd55a6c78007bd675fce5657613" name="a0b8f1bd55a6c78007bd675fce5657613"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Forward</b></td></tr>
<tr class="memdesc:a0b8f1bd55a6c78007bd675fce5657613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down vector constant {0, 0, 1}. <br /></td></tr>
<tr class="separator:a0b8f1bd55a6c78007bd675fce5657613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec707b6edbe78234a882965c6e03d00f" id="r_aec707b6edbe78234a882965c6e03d00f"><td class="memItemLeft" align="right" valign="top"><a id="aec707b6edbe78234a882965c6e03d00f" name="aec707b6edbe78234a882965c6e03d00f"></a>
static const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Backward</b></td></tr>
<tr class="memdesc:aec707b6edbe78234a882965c6e03d00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down vector constant {0, 0, -1}. <br /></td></tr>
<tr class="separator:aec707b6edbe78234a882965c6e03d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
struct SA::Vec3&lt; T &gt;</div><p><em>Vector</em> 3 Sapphire-Maths class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec431798fa6c107ccb7300b76815a60c" name="aec431798fa6c107ccb7300b76815a60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec431798fa6c107ccb7300b76815a60c">&#9670;&#160;</a></span>Vec3() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Vec3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_y</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_x</td><td>X axis value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_y</td><td>Y axis value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_z</td><td>Z axis value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34a5f13141b691e44f654b2da01277c1" name="a34a5f13141b691e44f654b2da01277c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a5f13141b691e44f654b2da01277c1">&#9670;&#160;</a></span>Vec3() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Vec3 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> <em>Value</em> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Axis value to apply on all axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89169fa09731ddf5769ad309badc456a" name="a89169fa09731ddf5769ad309badc456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89169fa09731ddf5769ad309badc456a">&#9670;&#160;</a></span>Vec3() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Vec3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; TIn &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor from another <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIn</td><td>Type of the input <a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td><a class="el" href="struct_s_a_1_1_vec3.html" title="Vector 3 Sapphire-Maths class.">Vec3</a> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95bd44fe25e3b919544c18bb5629cb16" name="a95bd44fe25e3b919544c18bb5629cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bd44fe25e3b919544c18bb5629cb16">&#9670;&#160;</a></span>Vec3() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Vec3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec2.html">Vec2</a>&lt; TIn &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_z</em><span class="paramdefsep"> = </span><span class="paramdefval">T(0)</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIn</td><td>Type of the in <a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td><a class="el" href="struct_s_a_1_1_vec2.html" title="Vector 2 Sapphire&#39;s class.">Vec2</a> to construct from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_z</td><td>Z axis value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d231da05962b084e351b8e432be1d31" name="a9d231da05962b084e351b8e432be1d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d231da05962b084e351b8e432be1d31">&#9670;&#160;</a></span>Vec3() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Vec3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec4.html">Vec4</a>&lt; TIn &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Value</em> constructor from <a class="el" href="struct_s_a_1_1_vec4.html" title="Vector 4 Sapphire-Maths class.">Vec4</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIn</td><td>Type of the in <a class="el" href="struct_s_a_1_1_vec4.html" title="Vector 4 Sapphire-Maths class.">Vec4</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td><a class="el" href="struct_s_a_1_1_vec4.html" title="Vector 4 Sapphire-Maths class.">Vec4</a> to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aefacccb9c1800f16d21f836c7bb53305" name="aefacccb9c1800f16d21f836c7bb53305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefacccb9c1800f16d21f836c7bb53305">&#9670;&#160;</a></span>Angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_normal</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt;&#160;T&#160;&gt;<a class="el" href="#ae2d208e3d26dcd54ac44634cb13ff437">::Up</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Signed Angle </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute angle with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute angle with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_normal</td><td>Normal of the plan between _lhs and _rhs, used to determine angle's sign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Signed Angle </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="ad5bea59741b832f9458c66b71ac38313" name="ad5bea59741b832f9458c66b71ac38313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bea59741b832f9458c66b71ac38313">&#9670;&#160;</a></span>AngleUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_a_1_1_deg.html">Deg</a>&lt; T &gt; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::AngleUnsigned </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Unsigned Angle </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute angle with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute angle with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Unsigned Angle </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="aa5a16055dc020384c0600913db252d38" name="aa5a16055dc020384c0600913db252d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a16055dc020384c0600913db252d38">&#9670;&#160;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Cross product </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_lhs</td><td>Left hand side operand to compute cross product with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand to compute cross product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Cross product </b> between _lhs and _rhs. </dd></dl>

</div>
</div>
<a id="aba337b1bd3b27961ccddab13aad517b1" name="aba337b1bd3b27961ccddab13aad517b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba337b1bd3b27961ccddab13aad517b1">&#9670;&#160;</a></span>Data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em> Const Getter </em> of vector data </p>
<dl class="section return"><dt>Returns</dt><dd>this vector as a const T*. </dd></dl>

</div>
</div>
<a id="ab3f1214681c2e9b5cc052bf0e3c9d310" name="ab3f1214681c2e9b5cc052bf0e3c9d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f1214681c2e9b5cc052bf0e3c9d310">&#9670;&#160;</a></span>Data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of vector data </p>
<dl class="section return"><dt>Returns</dt><dd>this vector as a T*. </dd></dl>

</div>
</div>
<a id="ae08f9bcb7d23975847368556b8b349b6" name="ae08f9bcb7d23975847368556b8b349b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08f9bcb7d23975847368556b8b349b6">&#9670;&#160;</a></span>Dir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Dir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Non-Normalized Direction </b> from _lhs and _rhs. </p>
<p>Direction get not normalized. Use DirN instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute direction from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute direction to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Non-Normalized Direction </b> from _start and _end. </dd></dl>

</div>
</div>
<a id="a2d6bbac4223c6780a24fcb00e7fb773c" name="a2d6bbac4223c6780a24fcb00e7fb773c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6bbac4223c6780a24fcb00e7fb773c">&#9670;&#160;</a></span>DirN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::DirN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Normalized Direction </b> from _start to _end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Starting point to compute direction from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>ending point to compute direction to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Normalized Direction </b> from _start to _end. </dd></dl>

</div>
</div>
<a id="a96584adc6b427565f338e1679664b20f" name="a96584adc6b427565f338e1679664b20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96584adc6b427565f338e1679664b20f">&#9670;&#160;</a></span>Dist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Distance </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute distance with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute distance with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Distance </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="ac65f5d482c808392ecba2aa95821c5fb" name="ac65f5d482c808392ecba2aa95821c5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65f5d482c808392ecba2aa95821c5fb">&#9670;&#160;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_lhs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Dot product </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_lhs</td><td>Left hand side operand to compute dot product with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand to compute dot product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Dot product </b> between _lhs and _rhs. </dd></dl>

</div>
</div>
<a id="a761ac855d03dab745b94c4dce7cb7d2e" name="a761ac855d03dab745b94c4dce7cb7d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761ac855d03dab745b94c4dce7cb7d2e">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_epsilon</em><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;T&#160;&gt;::epsilon()</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Other vector to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_epsilon</td><td>Epsilon value for threshold comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _other are equal. </dd></dl>

</div>
</div>
<a id="a5e8de02dadba2d97a0547186cb2bb29f" name="a5e8de02dadba2d97a0547186cb2bb29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8de02dadba2d97a0547186cb2bb29f">&#9670;&#160;</a></span>GetNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::GetNormalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Normalize</b> this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>new normalized vector. </dd></dl>

</div>
</div>
<a id="a9f94fba204d00430eb46e4a76f7dd6c9" name="a9f94fba204d00430eb46e4a76f7dd6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f94fba204d00430eb46e4a76f7dd6c9">&#9670;&#160;</a></span>IsNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::IsNormalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this vector is normalized. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this vector is normalized, otherwise false. </dd></dl>

</div>
</div>
<a id="a726eab4432b10af061a37a03bfcd5e47" name="a726eab4432b10af061a37a03bfcd5e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726eab4432b10af061a37a03bfcd5e47">&#9670;&#160;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::IsZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this vector is a zero vector. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this is a zero vector. </dd></dl>

</div>
</div>
<a id="a41c7de3637a67dc4fa044556aa23ad66" name="a41c7de3637a67dc4fa044556aa23ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c7de3637a67dc4fa044556aa23ad66">&#9670;&#160;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the <b>length</b> of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Length of this vector. </dd></dl>

</div>
</div>
<a id="af585fbd5402f1a99f3b770df9ca4268c" name="af585fbd5402f1a99f3b770df9ca4268c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af585fbd5402f1a99f3b770df9ca4268c">&#9670;&#160;</a></span>Lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Lerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Clamped Lerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Linear_interpolation">https://en.wikipedia.org/wiki/Linear_interpolation</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="a2ab418fd4903dae822dac2fecf590a50" name="a2ab418fd4903dae822dac2fecf590a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab418fd4903dae822dac2fecf590a50">&#9670;&#160;</a></span>LerpUnclamped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::LerpUnclamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Unclamped Lerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Linear_interpolation">https://en.wikipedia.org/wiki/Linear_interpolation</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="a5905cfba1c7382fb66570f0f8153aeea" name="a5905cfba1c7382fb66570f0f8153aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5905cfba1c7382fb66570f0f8153aeea">&#9670;&#160;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Normalize</b> this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector normalized. </dd></dl>

</div>
</div>
<a id="a8ccd574163e1760185bc35abb457c9c9" name="a8ccd574163e1760185bc35abb457c9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccd574163e1760185bc35abb457c9c9">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Other vector to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _rhs are non-equal. </dd></dl>

</div>
</div>
<a id="a6da21e9d0e4f0194cc2ec2aabcfacbaf" name="a6da21e9d0e4f0194cc2ec2aabcfacbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da21e9d0e4f0194cc2ec2aabcfacbaf">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Multiply</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="a554b40b3322fda63d5a6b0919ad0a732" name="a554b40b3322fda63d5a6b0919ad0a732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554b40b3322fda63d5a6b0919ad0a732">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector scaled. </dd></dl>

</div>
</div>
<a id="a5739589a9a141b2bc668b1b995b80067" name="a5739589a9a141b2bc668b1b995b80067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5739589a9a141b2bc668b1b995b80067">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Multiply</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a7bcbbcbeacf84206b6937d2e11d898a4" name="a7bcbbcbeacf84206b6937d2e11d898a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcbbcbeacf84206b6937d2e11d898a4">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Scale</b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector scaled. </dd></dl>

</div>
</div>
<a id="a8ad502d20a06154370025dcaeba650fd" name="a8ad502d20a06154370025dcaeba650fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad502d20a06154370025dcaeba650fd">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Add</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="a71284584bbe88be07bfd0776bf6cd6d0" name="a71284584bbe88be07bfd0776bf6cd6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71284584bbe88be07bfd0776bf6cd6d0">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Add</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a9db551395c1001204006254fa125fd69" name="a9db551395c1001204006254fa125fd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db551395c1001204006254fa125fd69">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the opposite signed vector. </p>
<dl class="section return"><dt>Returns</dt><dd>new opposite signed vector. </dd></dl>

</div>
</div>
<a id="aafbf31a6928f34e982587ed59b1597c8" name="aafbf31a6928f34e982587ed59b1597c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbf31a6928f34e982587ed59b1597c8">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Subtract</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to substract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="a18577b167e7145aa2b63bb65eac44150" name="a18577b167e7145aa2b63bb65eac44150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18577b167e7145aa2b63bb65eac44150">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Substract</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to substract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="ac7d02d7319cae213ce2dd4f295fe5251" name="ac7d02d7319cae213ce2dd4f295fe5251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d02d7319cae213ce2dd4f295fe5251">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Divide</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to divide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector result. </dd></dl>

</div>
</div>
<a id="a99bf4f9aef52c0d120ab1f07ebbaa251" name="a99bf4f9aef52c0d120ab1f07ebbaa251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf4f9aef52c0d120ab1f07ebbaa251">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Inverse Scale </b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Inverse scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector inverse-scaled. </dd></dl>

</div>
</div>
<a id="aaeb7fb34033777d10a52160a245c6de0" name="aaeb7fb34033777d10a52160a245c6de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb7fb34033777d10a52160a245c6de0">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>Divide</b> term by term vector values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Vector to divide.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector result. </dd></dl>

</div>
</div>
<a id="a05f2258c5f01aa6d3d1b12bf36bc6fcc" name="a05f2258c5f01aa6d3d1b12bf36bc6fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f2258c5f01aa6d3d1b12bf36bc6fcc">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>_scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Inverse Scale </b> each vector axis by _scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_scale</td><td>Scale value to apply on all axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>self vector inverse-scaled. </dd></dl>

</div>
</div>
<a id="a9e58bc3a008795ef4c716299023011f9" name="a9e58bc3a008795ef4c716299023011f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e58bc3a008795ef4c716299023011f9">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Default</em> assignment copy operator. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector assigned. </dd></dl>

</div>
</div>
<a id="aaa5fb3e002e81a64f4a1e124ee467385" name="aaa5fb3e002e81a64f4a1e124ee467385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5fb3e002e81a64f4a1e124ee467385">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Default</em> assignment move operator. </p>
<dl class="section return"><dt>Returns</dt><dd>self vector assigned. </dd></dl>

</div>
</div>
<a id="a746e117053cd6c1232cfea46b476185f" name="a746e117053cd6c1232cfea46b476185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746e117053cd6c1232cfea46b476185f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compare</em> 2 vector equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Other vector to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether this and _rhs are equal. </dd></dl>

</div>
</div>
<a id="a0ef2eab184cc6f2072181363d97c7577" name="a0ef2eab184cc6f2072181363d97c7577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2eab184cc6f2072181363d97c7577">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Access</em> operator by index: x, y, z using 0, 1, 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T value at index. </dd></dl>

</div>
</div>
<a id="a46b5f54f2425e67cbe7b215e52b190b8" name="a46b5f54f2425e67cbe7b215e52b190b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b5f54f2425e67cbe7b215e52b190b8">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em> Const Access </em> operator by index: x, y, z using 0, 1, 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T value at index. </dd></dl>

</div>
</div>
<a id="a5f2abde2aed199ac036f225dca64a908" name="a5f2abde2aed199ac036f225dca64a908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2abde2aed199ac036f225dca64a908">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Cross product </b> between this and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand vector to compute cross product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Cross product </b> between this vector and _other. </dd></dl>

</div>
</div>
<a id="a8a23365412643e0e5f1c95156d5b1c78" name="a8a23365412643e0e5f1c95156d5b1c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a23365412643e0e5f1c95156d5b1c78">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Dot product </b> between this and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_rhs</td><td>Right hand side operand vector to compute dot product with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Dot product </b> between this vector and _other. </dd></dl>

</div>
</div>
<a id="aea75b9cb08de179b249e2c64f5b6fc9b" name="aea75b9cb08de179b249e2c64f5b6fc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea75b9cb08de179b249e2c64f5b6fc9b">&#9670;&#160;</a></span>ProjectOnTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::ProjectOnTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Project</b> this vector onto an other vector. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Vector_projection">https://en.wikipedia.org/wiki/Vector_projection</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Vector used for projection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector projected. </dd></dl>

</div>
</div>
<a id="a6364017ec7e21931758bccbd41fa02bf" name="a6364017ec7e21931758bccbd41fa02bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6364017ec7e21931758bccbd41fa02bf">&#9670;&#160;</a></span>ProjectOnToNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::ProjectOnToNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_normal</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Project</b> this vector onto s normal. </p>
<p>Assume _normal is normalized. Use GetProjectOnTo() for non normalized vector. Reference: <a href="https://en.wikipedia.org/wiki/Vector_projection">https://en.wikipedia.org/wiki/Vector_projection</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_normal</td><td>Normal used for projection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector projected. </dd></dl>

</div>
</div>
<a id="a189a031a8a58021b0ce27217a3c40bc1" name="a189a031a8a58021b0ce27217a3c40bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189a031a8a58021b0ce27217a3c40bc1">&#9670;&#160;</a></span>Reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::Reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_normal</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_elasticity</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>Reflect</b> this vector over the normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_normal</td><td>Normal used for reflection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_elasticity</td><td>Elasticity reflection coefficient (use 1.0f for full reflection).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new vector reflected. </dd></dl>

</div>
</div>
<a id="a443b0b399993f9b8ac1edfde27c1e242" name="a443b0b399993f9b8ac1edfde27c1e242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443b0b399993f9b8ac1edfde27c1e242">&#9670;&#160;</a></span>SLerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::SLerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Clamped SLerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Slerp">https://en.wikipedia.org/wiki/Slerp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="a72833e3f8751a24e6fb85559178aad4b" name="a72833e3f8751a24e6fb85559178aad4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72833e3f8751a24e6fb85559178aad4b">&#9670;&#160;</a></span>SLerpUnclamped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a> <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::SLerpUnclamped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>_alpha</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b> Unclamped SLerp </b> from _start to _end at _alpha. </p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Slerp">https://en.wikipedia.org/wiki/Slerp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_start</td><td>Starting point of the lerp. </td></tr>
    <tr><td class="paramname">_end</td><td>Ending point of the lerp. </td></tr>
    <tr><td class="paramname">_alpha</td><td>Alpha of the lerp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolation between _start and _end. return _start when _alpha == 0.0f and _end when _alpha == 1.0f. </dd></dl>

</div>
</div>
<a id="a88592152a24687005ba4e63e88b6e96b" name="a88592152a24687005ba4e63e88b6e96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88592152a24687005ba4e63e88b6e96b">&#9670;&#160;</a></span>SqrDist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::SqrDist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_a_1_1_vec3.html">Vec3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Compute</em> the <b> Squared Distance </b> between _lhs and _rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_start</td><td>Left hand side operand to compute squared distance with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_end</td><td>Right hand side operand to compute squared distance with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b> Squared Distance </b> between _start and _end. </dd></dl>

</div>
</div>
<a id="a633f08fa9b7568e25e1c5092dfc5d20e" name="a633f08fa9b7568e25e1c5092dfc5d20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f08fa9b7568e25e1c5092dfc5d20e">&#9670;&#160;</a></span>SqrLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="struct_s_a_1_1_vec3.html">SA::Vec3</a>&lt; T &gt;::SqrLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Getter</em> of the <b> Squared Length </b> of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Squared Length of this vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>Include/SA/Maths/Matrix/<a class="el" href="_matrix3_8hpp_source.html">Matrix3.hpp</a></li>
<li>Include/SA/Maths/Space/<a class="el" href="_vector3_8hpp_source.html">Vector3.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
